/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { Addr, Timestamp, Uint64, Uint128, InstantiateMsg, Round, Coin, ExecuteMsg, QueryMsg, TupleOfUint32AndRound, String, IsActiveResponse, IsMemberResponse, MembersResponse, MintPriceResponse, ArrayOfTupleOfUint32AndRound } from "./OmniflixRoundWhitelist.types";
export interface OmniflixRoundWhitelistReadOnlyInterface {
  contractAddress: string;
  rounds: () => Promise<ArrayOfTupleOfUint32AndRound>;
  round: ({
    roundIndex
  }: {
    roundIndex: number;
  }) => Promise<Round>;
  isActive: () => Promise<IsActiveResponse>;
  activeRound: () => Promise<TupleOfUint32AndRound>;
  members: ({
    limit,
    roundIndex,
    startAfter
  }: {
    limit?: number;
    roundIndex: number;
    startAfter?: string;
  }) => Promise<MembersResponse>;
  price: () => Promise<MintPriceResponse>;
  isMember: ({
    address
  }: {
    address: string;
  }) => Promise<IsMemberResponse>;
  admin: () => Promise<String>;
}
export class OmniflixRoundWhitelistQueryClient implements OmniflixRoundWhitelistReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.rounds = this.rounds.bind(this);
    this.round = this.round.bind(this);
    this.isActive = this.isActive.bind(this);
    this.activeRound = this.activeRound.bind(this);
    this.members = this.members.bind(this);
    this.price = this.price.bind(this);
    this.isMember = this.isMember.bind(this);
    this.admin = this.admin.bind(this);
  }

  rounds = async (): Promise<ArrayOfTupleOfUint32AndRound> => {
    return this.client.queryContractSmart(this.contractAddress, {
      rounds: {}
    });
  };
  round = async ({
    roundIndex
  }: {
    roundIndex: number;
  }): Promise<Round> => {
    return this.client.queryContractSmart(this.contractAddress, {
      round: {
        round_index: roundIndex
      }
    });
  };
  isActive = async (): Promise<IsActiveResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_active: {}
    });
  };
  activeRound = async (): Promise<TupleOfUint32AndRound> => {
    return this.client.queryContractSmart(this.contractAddress, {
      active_round: {}
    });
  };
  members = async ({
    limit,
    roundIndex,
    startAfter
  }: {
    limit?: number;
    roundIndex: number;
    startAfter?: string;
  }): Promise<MembersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      members: {
        limit,
        round_index: roundIndex,
        start_after: startAfter
      }
    });
  };
  price = async (): Promise<MintPriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      price: {}
    });
  };
  isMember = async ({
    address
  }: {
    address: string;
  }): Promise<IsMemberResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_member: {
        address
      }
    });
  };
  admin = async (): Promise<String> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin: {}
    });
  };
}
export interface OmniflixRoundWhitelistInterface extends OmniflixRoundWhitelistReadOnlyInterface {
  contractAddress: string;
  sender: string;
  removeRound: ({
    roundIndex
  }: {
    roundIndex: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addRound: ({
    round
  }: {
    round: Round;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  privateMint: ({
    collector
  }: {
    collector: string;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addMembers: ({
    address,
    roundIndex
  }: {
    address: string[];
    roundIndex: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updatePrice: ({
    mintPrice,
    roundIndex
  }: {
    mintPrice: Coin;
    roundIndex: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class OmniflixRoundWhitelistClient extends OmniflixRoundWhitelistQueryClient implements OmniflixRoundWhitelistInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.removeRound = this.removeRound.bind(this);
    this.addRound = this.addRound.bind(this);
    this.privateMint = this.privateMint.bind(this);
    this.addMembers = this.addMembers.bind(this);
    this.updatePrice = this.updatePrice.bind(this);
  }

  removeRound = async ({
    roundIndex
  }: {
    roundIndex: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_round: {
        round_index: roundIndex
      }
    }, fee, memo, _funds);
  };
  addRound = async ({
    round
  }: {
    round: Round;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_round: {
        round
      }
    }, fee, memo, _funds);
  };
  privateMint = async ({
    collector
  }: {
    collector: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      private_mint: {
        collector
      }
    }, fee, memo, _funds);
  };
  addMembers = async ({
    address,
    roundIndex
  }: {
    address: string[];
    roundIndex: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_members: {
        address,
        round_index: roundIndex
      }
    }, fee, memo, _funds);
  };
  updatePrice = async ({
    mintPrice,
    roundIndex
  }: {
    mintPrice: Coin;
    roundIndex: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_price: {
        mint_price: mintPrice,
        round_index: roundIndex
      }
    }, fee, memo, _funds);
  };
}